<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>4.4. 高级合并</title>
<link rel="stylesheet" href="styles.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.3">
<link rel="home" href="index.html" title="Subversion 权威指南">
<link rel="up" href="svn.branchmerge.html" title="第 4 章 分支与合并">
<link rel="prev" href="svn.branchmerge.basicmerging.html" title="4.3. 基本合并">
<link rel="next" href="svn.branchmerge.switchwc.html" title="4.5. 使用分支">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr><th colspan="3" align="center">4.4. 高级合并</th></tr>
<tr>
<td width="20%" align="left">
<a accesskey="p" href="svn.branchmerge.basicmerging.html">上一页</a> </td>
<th width="60%" align="center">第 4 章 分支与合并</th>
<td width="20%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">下一页</a>
</td>
</tr>
</table>
<hr>
</div>
<div class="sect1" lang="zh">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="svn.branchmerge.advanced"></a>4.4. 高级合并</h2></div></div></div>
<p>Here ends the automated magic.  Sooner or later, once you get the hang of
branching and merging, you're going to have to ask Subversion to merge
<span class="emphasis"><em>specific</em></span> changes from one place to another.  To do
this, you're going to have to start passing more complicated arguments to
<span class="command"><strong>svn merge</strong></span>.  The next section describes the fully expanded
syntax of the command and discusses a number of common scenarios that
require it.</p>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.cherrypicking"></a>4.4.1. 摘录合并</h3></div></div></div>
<p>Just as the term “<span class="quote">changeset</span>” is often used in version control
systems, so is the term <em class="firstterm">cherrypicking</em>.  This word
refers to the act of choosing <span class="emphasis"><em>one</em></span> specific changeset
from a branch and replicating it to another.  Cherrypicking may also refer
to the act of duplicating a particular set of (not necessarily contiguous!)
changesets from one branch to another.  This is in contrast to more typical
merging scenarios, where the “<span class="quote">next</span>” contiguous range of
revisions is duplicated automatically.</p>
<p>Why would people want to replicate just a single change? It comes up more
often than you'd think.  For example, let's go back in time and imagine that
you haven't yet merged your private feature branch back to the trunk.  At
the water cooler, you get word that Sally made an interesting change to
<code class="filename">integer.c</code> on the trunk.  Looking over the history of
commits to the trunk, you see that in revision 355 she fixed a critical bug
that directly impacts the feature you're working on.  You might not be ready
to merge all the trunk changes to your branch just yet, but you certainly
need that particular bug fix in order to continue your work.</p>
<pre class="screen">
$ svn diff -c 355 ^/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 354)
+++ integer.c	(revision 355)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CP/MM");
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
</pre>
<p>Just as you used <span class="command"><strong>svn diff</strong></span> in the prior example to examine
revision 355, you can pass the same option to <span class="command"><strong>svn merge</strong></span>:</p>
<pre class="screen">
$ svn merge -c 355 ^/trunk
U    integer.c

$ svn status
M      integer.c
</pre>
<p>You can now go through the usual testing procedures before committing this
change to your branch.  After the commit, Subversion marks r355 as having
been merged to the branch so that future “<span class="quote">magic</span>” merges that
synchronize your branch with the trunk know to skip over r355.  (Merging the
same change to the same branch almost always results in a conflict!)</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:341-349,355

# Notice that r355 isn't listed as "eligible" to merge, because
# it's already been merged.
$ svn mergeinfo ^/trunk --show-revs eligible
r350
r351
r352
r353
r354
r356
r357
r358
r359
r360

$ svn merge ^/trunk
--- Merging r350 through r354 into '.':
 U   .
U    integer.c
U    Makefile
--- Merging r356 through r360 into '.':
 U   .
U    integer.c
U    button.c
</pre>
<p>This use case of replicating (or <em class="firstterm">backporting</em>) bug
fixes from one branch to another is perhaps the most popular reason for
cherrypicking changes; it comes up all the time, for example, when a team is
maintaining a “<span class="quote">release branch</span>” of software.  (We discuss this
pattern in <a class="xref" href="svn.branchmerge.commonpatterns.html#svn.branchmerge.commonpatterns.release" title="4.8.1. 发布分支">第 4.8.1 节 “发布分支”</a>.)</p>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[警告]" src="images/warning.png"></td>
<th align="left">警告</th>
</tr>
<tr><td align="left" valign="top"><p>Did you notice how, in the last example, the merge invocation caused two
distinct ranges of merges to be applied? The <span class="command"><strong>svn merge</strong></span>
command applied two independent patches to your working copy to skip over
changeset 355, which your branch already contained.  There's nothing
inherently wrong with this, except that it has the potential to make
conflict resolution trickier.  If the first range of changes creates
conflicts, you <span class="emphasis"><em>must</em></span> resolve them interactively for the
merge process to continue and apply the second range of changes.  If you
postpone a conflict from the first wave of changes, the whole merge command
will bail out with an error message.  <sup>[<a name="id363853" href="#ftn.id363853" class="footnote">23</a>]</sup> 
        </p></td></tr>
</table></div>
<p>A word of warning: while <span class="command"><strong>svn diff</strong></span> and <span class="command"><strong>svn
merge</strong></span> are very similar in concept, they do have different syntax
in many cases.  Be sure to read about them in <a class="xref" href="svn.ref.html" title="第 9 章 Subversion 完全参考">第 9 章 <i>Subversion 完全参考</i></a> for
details, or ask <span class="command"><strong>svn help</strong></span>.  For example, <span class="command"><strong>svn
merge</strong></span> requires a working copy path as a target, that is, a place
where it should apply the generated patch.  If the target isn't specified,
it assumes you are trying to perform one of the following common operations:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>你希望合并目录修改到工作副本的当前目录。</p></li>
<li><p>你希望合并修改到你的当前工作目录的相同文件名的文件。</p></li>
</ul></div>
<p>If you are merging a directory and haven't specified a target path,
<span class="command"><strong>svn merge</strong></span> assumes the first case and tries to apply the
changes into your current directory.  If you are merging a file, and that
file (or a file by the same name) exists in your current working directory,
<span class="command"><strong>svn merge</strong></span> assumes the second case and tries to apply the
changes to a local file with the same name.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.advancedsyntax"></a>4.4.2. 合并的语法：完整的描述</h3></div></div></div>
<p>You've now seen some examples of the <span class="command"><strong>svn merge</strong></span> command,
and you're about to see several more.  If you're feeling confused about
exactly how merging works, you're not alone.  Many users (especially those
new to version control) are initially perplexed about the proper syntax of
the command and about how and when the feature should be used.  But fear
not, this command is actually much simpler than you think! There's a very
easy technique for understanding exactly how <span class="command"><strong>svn merge</strong></span>
behaves.</p>
<p>The main source of confusion is the <span class="emphasis"><em>name</em></span> of the
command.  The term “<span class="quote">merge</span>” somehow denotes that branches are
combined together, or that some sort of mysterious blending of data is going
on.  That's not the case.  A better name for the command might have been
<span class="command"><strong>svn diff-and-apply</strong></span>, because that's all that happens: two
repository trees are compared, and the differences are applied to a working
copy.</p>
<p>If you're using <span class="command"><strong>svn merge</strong></span> to do basic copying of changes
between branches, it will generally do the right thing automatically.  For
example, a command such as the following:</p>
<pre class="screen">
$ svn merge ^/branches/some-branch
</pre>
<p>will attempt to duplicate any changes made on
<code class="filename">some-branch</code> into your current working directory, which
is presumably a working copy that shares some historical connection to the
branch.  The command is smart enough to only duplicate changes that your
working copy doesn't yet have.  If you repeat this command once a week, it
will only duplicate the “<span class="quote">newest</span>” branch changes that happened
since you last merged.</p>
<p>If you choose to use the <span class="command"><strong>svn merge</strong></span> command in all its
full glory by giving it specific revision ranges to duplicate, the command
takes three main arguments:</p>
<div class="orderedlist"><ol type="1">
<li><p>初始的版本树(通常叫做比较的<em class="firstterm">左边</em>)，</p></li>
<li><p>最终的版本树(通常叫做比较的<em class="firstterm">右边</em>)，</p></li>
<li><p>一个接收区别的工作副本(通常叫做合并的<em class="firstterm">目标</em>)。</p></li>
</ol></div>
<p>Once these three arguments are specified, the two trees are compared, and
the differences are applied to the target working copy as local
modifications.  When the command is done, the results are no different than
if you had hand-edited the files or run various <span class="command"><strong>svn add</strong></span>
or <span class="command"><strong>svn delete</strong></span> commands yourself.  If you like the
results, you can commit them.  If you don't like the results, you can simply
<span class="command"><strong>svn revert</strong></span> all of the changes.</p>
<p>The syntax of <span class="command"><strong>svn merge</strong></span> allows you to specify the three
necessary arguments rather flexibly.  Here are some examples:</p>
<pre class="screen">
$ svn merge http://svn.example.com/repos/branch1@150 \
            http://svn.example.com/repos/branch2@212 \
            my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk my-working-copy

$ svn merge -r 100:200 http://svn.example.com/repos/trunk
</pre>
<p>The first syntax lays out all three arguments explicitly, naming each tree
in the form <span class="emphasis"><em>URL@REV</em></span> and naming the working copy
target.  The second syntax can be used as a shorthand for situations when
you're comparing two different revisions of the same URL.  The last syntax
shows how the working copy argument is optional; if omitted, it defaults to
the current directory.</p>
<p>While the first example shows the “<span class="quote">full</span>” syntax of <span class="command"><strong>svn
merge</strong></span>, it needs to be used very carefully; it can result in merges
which do not record any <code class="literal">svn:mergeinfo</code> metadata at all.
The next section talks a bit more about this.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.nomergedata"></a>4.4.3. 不使用合并信息的合并</h3></div></div></div>
<p>Subversion tries to generate merge metadata whenever it can, to make future
invocations of <span class="command"><strong>svn merge</strong></span> smarter.  There are still
situations, however, where <code class="literal">svn:mergeinfo</code> data is not
created or changed.  Remember to be a bit wary of these scenarios:</p>
<div class="variablelist"><dl>
<dt><span class="term">合并无关的源</span></dt>
<dd><p>If you ask <span class="command"><strong>svn merge</strong></span> to compare two URLs that aren't
related to each other, a patch will still be generated and applied to your
working copy, but no merging metadata will be created.  There's no common
history between the two sources, and future “<span class="quote">smart</span>” merges
depend on that common history.</p></dd>
<dt><span class="term">从外部版本库合并</span></dt>
<dd><p>While it's possible to run a command such as <strong class="userinput"><code>svn merge -r 100:200
<em class="replaceable"><code>http://svn.foreignproject.com/repos/trunk</code></em></code></strong>,
the resultant patch will also lack any historical merge metadata.  At time
of this writing, Subversion has no way of representing different repository
URLs within the <code class="literal">svn:mergeinfo</code> property.</p></dd>
<dt><span class="term">使用 <code class="option">--ignore-ancestry</code></span></dt>
<dd><p>If this option is passed to <span class="command"><strong>svn merge</strong></span>, it causes the
merging logic to mindlessly generate differences the same way that
<span class="command"><strong>svn diff</strong></span> does, ignoring any historical relationships.  We
discuss this later in the chapter in <a class="xref" href="svn.branchmerge.advanced.html#svn.branchmerge.advanced.ancestry" title="4.4.7. 关注还是忽视祖先">第 4.4.7 节 “关注还是忽视祖先”</a>.</p></dd>
<dt><span class="term">应用反向合并到目标的自然历史</span></dt>
<dd><p>Earlier in this chapter (<a class="xref" href="svn.branchmerge.basicmerging.html#svn.branchmerge.basicmerging.undo" title="4.3.4. 取消修改">第 4.3.4 节 “取消修改”</a>)  we discussed how to use
<span class="command"><strong>svn merge</strong></span> to apply a “<span class="quote">reverse patch</span>” as a
way of rolling back changes.  If this technique is used to undo a change to
an object's personal history (e.g., commit r5 to the trunk, then immediately
roll back r5 using <strong class="userinput"><code>svn merge . -c -5</code></strong>), this sort of
merge doesn't affect the recorded mergeinfo.  <sup>[<a name="id364249" href="#ftn.id364249" class="footnote">24</a>]</sup>
            </p></dd>
</dl></div>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.mergeconflicts"></a>4.4.4. 合并冲突</h3></div></div></div>
<p>Just like the <span class="command"><strong>svn update</strong></span> command, <span class="command"><strong>svn
merge</strong></span> applies changes to your working copy.  And therefore it's
also capable of creating conflicts.  The conflicts produced by <span class="command"><strong>svn
merge</strong></span>, however, are sometimes different, and this section explains
those differences.</p>
<p>To begin with, assume that your working copy has no local edits.  When you
<span class="command"><strong>svn update</strong></span> to a particular revision, the changes sent by
the server will always apply “<span class="quote">cleanly</span>” to your working copy.
The server produces the delta by comparing two trees: a virtual snapshot of
your working copy, and the revision tree you're interested in.  Because the
left hand side of the comparison is exactly equal to what you already have,
the delta is guaranteed to correctly convert your working copy into the
right hand tree.</p>
<p>But <span class="command"><strong>svn merge</strong></span> has no such guarantees and can be much more
chaotic: the advanced user can ask the server to compare
<span class="emphasis"><em>any</em></span> two trees at all, even ones that are unrelated to
the working copy! This means there's large potential for human error.  Users
will sometimes compare the wrong two trees, creating a delta that doesn't
apply cleanly.  <span class="command"><strong>svn merge</strong></span> will do its best to apply as
much of the delta as possible, but some parts may be impossible.  Just as
the Unix <span class="command"><strong>patch</strong></span> command sometimes complains about
“<span class="quote">failed hunks,</span>” <span class="command"><strong>svn merge</strong></span> will similarly
complain about “<span class="quote">skipped targets</span>”:</p>
<pre class="screen">
$ svn merge -r 1288:1351 ^/branches/mybranch
U    foo.c
U    bar.c
Skipped missing target: 'baz.c'
U    glub.c
U    sputter.h

Conflict discovered in 'glorb.h'.
Select: (p) postpone, (df) diff-full, (e) edit,
        (h) help for more options:
</pre>
<p>In the previous example, it might be the case that
<code class="filename">baz.c</code> exists in both snapshots of the branch being
compared, and the resultant delta wants to change the file's contents, but
the file doesn't exist in the working copy.  Whatever the case, the
“<span class="quote">skipped</span>” message means that the user is most likely comparing
the wrong two trees; it's the classic sign of user error.  When this
happens, it's easy to recursively revert all the changes created by the
merge (<strong class="userinput"><code>svn revert . --recursive</code></strong>), delete any
unversioned files or directories left behind after the revert, and rerun
<span class="command"><strong>svn merge</strong></span> with different arguments.</p>
<p>Also notice that the preceding example shows a conflict happening on
<code class="filename">glorb.h</code>.  We already stated that the working copy has
no local edits: how can a conflict possibly happen? Again, because the user
can use <span class="command"><strong>svn merge</strong></span> to define and apply any old delta to
the working copy, that delta may contain textual changes that don't cleanly
apply to a working file, even if the file has no local modifications.</p>
<p>Another small difference between <span class="command"><strong>svn update</strong></span> and
<span class="command"><strong>svn merge</strong></span> is the names of the full-text files created
when a conflict happens.  In <a class="xref" href="svn.tour.cycle.html#svn.tour.cycle.resolve" title="2.4.5. 解决冲突(合并别人的修改)">第 2.4.5 节 “解决冲突(合并别人的修改)”</a>, we
saw that an update produces files named <code class="filename">filename.mine</code>,
<code class="filename">filename.rOLDREV</code>, and
<code class="filename">filename.rNEWREV</code>.  When <span class="command"><strong>svn merge</strong></span>
produces a conflict, though, it creates three files named
<code class="filename">filename.working</code>, <code class="filename">filename.left</code>,
and <code class="filename">filename.right</code>.  In this case, the terms
“<span class="quote">left</span>” and “<span class="quote">right</span>” are describing which side of
the double-tree comparison the file came from.  In any case, these differing
names will help you distinguish between conflicts that happened as a result
of an update and ones that happened as a result of a merge.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.blockchanges"></a>4.4.5. 阻塞修改</h3></div></div></div>
<p>Sometimes there's a particular changeset that you don't want to be
automatically merged.  For example, perhaps your team's policy is to do new
development work on <code class="filename">/trunk</code>, but to be more conservative
about backporting changes to a stable branch you use for releasing to the
public.  On one extreme, you can manually cherrypick single changesets from
the trunk to the branch—just the changes that are stable enough to
pass muster.  Maybe things aren't quite that strict, though; perhaps most of
the time you'd like to just let <span class="command"><strong>svn merge</strong></span> automatically
merge most changes from trunk to branch.  In this case, you'd like a way to
mask a few specific changes out, that is, prevent them from ever being
automatically merged.</p>
<p>In Subversion 1.5, the only way to block a changeset is to make the system
believe that the change has <span class="emphasis"><em>already</em></span> been merged.  To do
this, one can invoke a merge command with the <code class="option">--record-only</code>
option:</p>
<pre class="screen">
$ cd my-calc-branch

$ svn propget svn:mergeinfo .
/trunk:1680-3305

# Let's make the metadata list r3328 as already merged.
$ svn merge -c 3328 --record-only ^/trunk

$ svn status
M     .

$ svn propget svn:mergeinfo .
/trunk:1680-3305,3328

$ svn commit -m "Block r3328 from being merged to the branch."
…
</pre>
<p>This technique works, but it's also a little bit dangerous.  The main
problem is that we're not clearly differentiating between the ideas of
“<span class="quote">I already have this change</span>” and “<span class="quote">I don't have this
change.</span>” We're effectively lying to the system, making it think that
the change was previously merged.  This puts the responsibility on
you—the user—to remember that the change wasn't actually merged,
it just wasn't wanted.  There's no way to ask Subversion for a list of
“<span class="quote">blocked changelists.</span>” If you want to track them (so that you
can unblock them someday). you'll need to record them in a text file
somewhere, or perhaps in an invented property.  In Subversion 1.5,
unfortunately, this is the only way to manage blocked revisions; the plans
are to make a better interface for this in future versions.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.logblame"></a>4.4.6. 感知合并的日志和注解</h3></div></div></div>
<p>One of the main features of any version control system is to keep track of
who changed what, and when they did it.  The <span class="command"><strong>svn log</strong></span> and
<span class="command"><strong>svn blame</strong></span> commands are just the tools for this: when
invoked on individual files, they show not only the history of changesets
that affected the file, but also exactly which user wrote which line of
code, and when she did it.</p>
<p>When changes start getting replicated between branches, however, things
start to get complicated.  For example, if you were to ask <span class="command"><strong>svn
log</strong></span> about the history of your feature branch, it would show
exactly every revision that ever affected the branch:</p>
<pre class="screen">
$ cd my-calc-branch
$ svn log -q
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
------------------------------------------------------------------------
r388 | user | 2002-11-21 05:20:00 -0600 (Thu, 21 Nov 2002) | 2 lines
------------------------------------------------------------------------
r381 | user | 2002-11-20 15:07:06 -0600 (Wed, 20 Nov 2002) | 2 lines
------------------------------------------------------------------------
r359 | user | 2002-11-19 19:19:20 -0600 (Tue, 19 Nov 2002) | 2 lines
------------------------------------------------------------------------
r357 | user | 2002-11-15 14:29:52 -0600 (Fri, 15 Nov 2002) | 2 lines
------------------------------------------------------------------------
r343 | user | 2002-11-07 13:50:10 -0600 (Thu, 07 Nov 2002) | 2 lines
------------------------------------------------------------------------
r341 | user | 2002-11-03 07:17:16 -0600 (Sun, 03 Nov 2002) | 2 lines
------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
------------------------------------------------------------------------
</pre>
<p>But is this really an accurate picture of all the changes that happened on
the branch? What's being left out here is the fact that revisions 390, 381,
and 357 were actually the results of merging changes from the trunk.  If you
look at one of these logs in detail, the multiple trunk changesets that
comprised the branch change are nowhere to be seen:</p>
<pre class="screen">
$ svn log -v -r 390
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Changed paths:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Final merge of trunk changes to my-calc-branch.
</pre>
<p>We happen to know that this merge to the branch was nothing but a merge of
trunk changes.  How can we see those trunk changes as well? The answer is to
use the <code class="option">--use-merge-history</code> (<code class="option">-g</code>)  option.
This option expands those “<span class="quote">child</span>” changes that were part of the
merge.</p>
<pre class="screen">
$ svn log -v -r 390 -g
------------------------------------------------------------------------
r390 | user | 2002-11-22 11:01:57 -0600 (Fri, 22 Nov 2002) | 1 line
Changed paths:
   M /branches/my-calc-branch/button.c
   M /branches/my-calc-branch/README

Final merge of trunk changes to my-calc-branch.
------------------------------------------------------------------------
r383 | sally | 2002-11-21 03:19:00 -0600 (Thu, 21 Nov 2002) | 2 lines
Changed paths:
   M /branches/my-calc-branch/button.c
Merged via: r390

Fix inverse graphic error on button.
------------------------------------------------------------------------
r382 | sally | 2002-11-20 16:57:06 -0600 (Wed, 20 Nov 2002) | 2 lines
Changed paths:
   M /branches/my-calc-branch/README
Merged via: r390

Document my last fix in README.
</pre>
<p>By making the log operation use merge history, we see not just the revision
we queried (r390), but also the two revisions that came along on the ride
with it—a couple of changes made by Sally to the trunk.  This is a
much more complete picture of history!</p>
<p>The <span class="command"><strong>svn blame</strong></span> command also takes the
<code class="option">--use-merge-history</code> (<code class="option">-g</code>)  option.  If this
option is neglected, somebody looking at a line-by-line annotation of
<code class="filename">button.c</code> may get the mistaken impression that you were
responsible for the lines that fixed a certain error:</p>
<pre class="screen">
$ svn blame button.c
…
   390    user    retval = inverse_func(button, path);
   390    user    return retval;
   390    user    }
…
</pre>
<p>And while it's true that you did actually commit those three lines in
revision 390, two of them were actually written by Sally back in revision
383:</p>
<pre class="screen">
$ svn blame button.c -g
…
G    383    sally   retval = inverse_func(button, path);
G    383    sally   return retval;
     390    user    }
…
</pre>
<p>Now we know who to <span class="emphasis"><em>really</em></span> blame for those two lines of
code!</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.ancestry"></a>4.4.7. 关注还是忽视祖先</h3></div></div></div>
<p>When conversing with a Subversion developer, you might very likely hear
reference to the term <em class="firstterm">ancestry</em>.  This word is used to
describe the relationship between two objects in a repository: if they're
related to each other, one object is said to be an ancestor of the other.</p>
<p>For example, suppose you commit revision 100, which includes a change to a
file <code class="filename">foo.c</code>.  Then <code class="filename">foo.c@99</code> is an
“<span class="quote">ancestor</span>” of <code class="filename">foo.c@100</code>.  On the other
hand, suppose you commit the deletion of <code class="filename">foo.c</code> in
revision 101, and then add a new file by the same name in revision 102.  In
this case, <code class="filename">foo.c@99</code> and <code class="filename">foo.c@102</code>
may appear to be related (they have the same path), but in fact are
completely different objects in the repository.  They share no history or
“<span class="quote">ancestry.</span>”</p>
<p>The reason for bringing this up is to point out an important difference
between <span class="command"><strong>svn diff</strong></span> and <span class="command"><strong>svn merge</strong></span>.  The
former command ignores ancestry, while the latter command is quite sensitive
to it.  For example, if you asked <span class="command"><strong>svn diff</strong></span> to compare
revisions 99 and 102 of <code class="filename">foo.c</code>, you would see line-based
diffs; the <span class="command"><strong>diff</strong></span> command is blindly comparing two paths.
But if you asked <span class="command"><strong>svn merge</strong></span> to compare the same two
objects, it would notice that they're unrelated and first attempt to delete
the old file, then add the new file; the output would indicate a deletion
followed by an add:</p>
<pre class="screen">
D    foo.c
A    foo.c
      </pre>
<p>Most merges involve comparing trees that are ancestrally related to one
another; therefore, <span class="command"><strong>svn merge</strong></span> defaults to this behavior.
Occasionally, however, you may want the <span class="command"><strong>merge</strong></span> command to
compare two unrelated trees.  For example, you may have imported two
source-code trees representing different vendor releases of a software
project (see <a class="xref" href="svn.advanced.vendorbr.html" title="4.9. 供方分支">第 4.9 节 “供方分支”</a>).  If you ask
<span class="command"><strong>svn merge</strong></span> to compare the two trees, you'd see the entire
first tree being deleted, followed by an add of the entire second tree! In
these situations, you'll want <span class="command"><strong>svn merge</strong></span> to do a
path-based comparison only, ignoring any relations between files and
directories.  Add the <code class="option">--ignore-ancestry</code> option to your
<span class="command"><strong>merge</strong></span> command, and it will behave just like <span class="command"><strong>svn
diff</strong></span>.  (And conversely, the <code class="option">--notice-ancestry</code>
option will cause <span class="command"><strong>svn diff</strong></span> to behave like the
<span class="command"><strong>svn merge</strong></span> command.)</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.moves"></a>4.4.8. 合并和移动</h3></div></div></div>
<p>A common desire is to refactor source code, especially in Java-based
software projects.  Files and directories are shuffled around and renamed,
often causing great disruption to everyone working on the project.  Sounds
like a perfect case to use a branch, doesn't it? Just create a branch,
shuffle things around, and then merge the branch back to the trunk, right?</p>
<p>唉，这个场景下这样并不正确，可以看作 Subversion 当前的弱点。这个问题是因为 Subversion 的
<span class="command"><strong>update</strong></span> 还不是足够强壮，特别是针对拷贝和移动操作。</p>
<p>When you use <span class="command"><strong>svn copy</strong></span> to duplicate a file, the repository
remembers where the new file came from, but it fails to transmit that
information to the client which is running <span class="command"><strong>svn update</strong></span> or
<span class="command"><strong>svn merge</strong></span>.  Instead of telling the client, “<span class="quote">Copy
that file you already have to this new location,</span>” it sends down an
entirely new file.  This can lead to problems, especially because the same
thing happens with renamed files.  A lesser-known fact about Subversion is
that it lacks “<span class="quote">true renames</span>”—the <span class="command"><strong>svn
move</strong></span> command is nothing more than an aggregation of <span class="command"><strong>svn
copy</strong></span> and <span class="command"><strong>svn delete</strong></span>.</p>
<p>For example, suppose that while working on your private branch, you rename
<code class="filename">integer.c</code> to <code class="filename">whole.c</code>.  Effectively
you've created a new file in your branch that is a copy of the original
file, and deleted the original file.  Meanwhile, back on
<code class="filename">trunk</code>, Sally has committed some improvements to
<code class="filename">integer.c</code>.  Now you decide to merge your branch to the
trunk:</p>
<pre class="screen">
$ cd calc/trunk

$ svn merge --reintegrate ^/branches/my-calc-branch
--- Merging differences between repository URLs into '.':
D   integer.c
A   whole.c
U   .
      </pre>
<p>This doesn't look so bad at first glance, but it's also probably not what
you or Sally expected.  The merge operation has deleted the latest version
of the <code class="filename">integer.c</code> file (the one containing Sally's
latest changes), and blindly added your new <code class="filename">whole.c</code>
file—which is a duplicate of the <span class="emphasis"><em>older</em></span> version of
<code class="filename">integer.c</code>.  The net effect is that merging your
“<span class="quote">rename</span>” to the branch has removed Sally's recent changes from
the latest revision!</p>
<p>This isn't true data loss.  Sally's changes are still in the repository's
history, but it may not be immediately obvious that this has happened.  The
moral of this story is that until Subversion improves, be very careful about
merging copies and renames from one branch to another.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.pre1.5clients"></a>4.4.9. 阻塞不知道合并的客户端</h3></div></div></div>
<p>If you've just upgraded your server to Subversion 1.5 or later, there's a
significant risk that pre-1.5 Subversion clients can mess up your automated
merge tracking.  Why is this? When a pre-1.5 Subversion client performs
<span class="command"><strong>svn merge</strong></span>, it doesn't modify the value of the
<code class="literal">svn:mergeinfo</code> property at all.  So the subsequent commit,
despite being the result of a merge, doesn't tell the repository about the
duplicated changes—that information is lost.  Later on, when
“<span class="quote">merge-aware</span>” clients attempt automatic merging, they're likely
to run into all sorts of conflicts resulting from repeated merges.</p>
<p>If you and your team are relying on the merge-tracking features of
Subversion, you may want to configure your repository to prevent older
clients from committing changes.  The easy way to do this is by inspecting
the “<span class="quote">capabilities</span>” parameter in the
<code class="literal">start-commit</code> hook script.  If the client reports itself
as having <code class="literal">mergeinfo</code> capabilities, the hook script can
allow the commit to start.  If the client doesn't report that capability,
have the hook deny the commit.  We'll learn more about hook scripts in the
next chapter; see <a class="xref" href="svn.reposadmin.create.html#svn.reposadmin.create.hooks" title="5.3.2. 实现版本库钩子">第 5.3.2 节 “实现版本库钩子”</a> and <a class="xref" href="svn.ref.reposhooks.start-commit.html" title="start-commit">start-commit</a> for details.</p>
</div>
<div class="sect2" lang="zh">
<div class="titlepage"><div><div><h3 class="title">
<a name="svn.branchmerge.advanced.finalword"></a>4.4.10. 合并跟踪的最终信息</h3></div></div></div>
<p>The bottom line is that Subversion's merge-tracking feature has an extremely
complex internal implementation, and the <code class="literal">svn:mergeinfo</code>
property is the only window the user has into the machinery.  Because the
feature is relatively new, a numbers of edge cases and possible unexpected
behaviors may pop up.</p>
<p>For example, sometimes mergeinfo will be generated when running a simple
<span class="command"><strong>svn copy</strong></span> or <span class="command"><strong>svn move</strong></span> command.
Sometimes mergeinfo will appear on files that you didn't expect to be
touched by an operation.  Sometimes mergeinfo won't be generated at all,
when you expect it to.  Furthermore, the management of mergeinfo metadata
has a whole set of taxonomies and behaviors around it, such as
“<span class="quote">explicit</span>” versus “<span class="quote">implicit</span>” mergeinfo,
“<span class="quote">operative</span>” versus “<span class="quote">inoperative</span>” revisions,
specific mechanisms of mergeinfo “<span class="quote">elision,</span>” and even
“<span class="quote">inheritance</span>” from parent to child directories.</p>
<p>We've chosen not to cover these detailed topics in this book for a couple of
reasons.  First, the level of detail is absolutely overwhelming for a
typical user.  Second, as Subversion continues to improve, we feel that a
typical user <span class="emphasis"><em>shouldn't</em></span> have to understand these
concepts; they'll eventually fade into the background as pesky
implementation details.  All that said, if you enjoy this sort of thing, you
can get a fantastic overview in a paper posted at CollabNet's website:
<a class="ulink" href="http://www.collab.net/community/subversion/articles/merge-info.html" target="_top">http://www.collab.net/community/subversion/articles/merge-info.html</a>.</p>
<p>For now, if you want to steer clear of bugs and odd behaviors in automatic
merging, the CollabNet article recommends that you stick to these simple
best practices:</p>
<div class="itemizedlist"><ul type="disc">
<li><p>For short-term feature branches, follow the simple procedure described
throughout <a class="xref" href="svn.branchmerge.basicmerging.html" title="4.3. 基本合并">第 4.3 节 “基本合并”</a>.</p></li>
<li><p>For long-lived release branches (as described in <a class="xref" href="svn.branchmerge.commonpatterns.html" title="4.8. 常用分支模式">第 4.8 节 “常用分支模式”</a>), perform merges only on the root
of the branch, not on subdirectories.</p></li>
<li><p>Never merge into working copies with a mixture of working revision numbers,
or with “<span class="quote">switched</span>” subdirectories (as described next in <a class="xref" href="svn.branchmerge.switchwc.html" title="4.5. 使用分支">第 4.5 节 “使用分支”</a>).  A merge target should be a working
copy which represents a <span class="emphasis"><em>single</em></span> location in the
repository at a single point in time.</p></li>
<li><p>Don't ever edit the <code class="literal">svn:mergeinfo</code> property directly; use
<span class="command"><strong>svn merge</strong></span> with the <code class="option">--record-only</code> option
to effect a desired change to the metadata (as demonstrated in <a class="xref" href="svn.branchmerge.advanced.html#svn.branchmerge.advanced.blockchanges" title="4.4.5. 阻塞修改">第 4.4.5 节 “阻塞修改”</a>).</p></li>
<li><p>Always make sure you have complete read access to all of your merge sources,
and that your target working copy has no sparse directories.</p></li>
</ul></div>
</div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a name="ftn.id363853" href="#id363853" class="para">23</a>] </sup>At least, this is true in Subversion 1.5 at the time of this writing.  This
behavior may improve in future versions of Subversion.</p></div>
<div class="footnote"><p><sup>[<a name="ftn.id364249" href="#id364249" class="para">24</a>] </sup>Interestingly, after rolling back a revision like this, we wouldn't be able
to reapply the revision using <strong class="userinput"><code>svn merge . -c 5</code></strong>, since
the mergeinfo would already list r5 as being applied.  We would have to use
the <code class="option">--ignore-ancestry</code> option to make the merge command
ignore the existing mergeinfo!</p></div>
</div>
</div>
<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left">
<a accesskey="p" href="svn.branchmerge.basicmerging.html">上一页</a> </td>
<td width="20%" align="center"><a accesskey="u" href="svn.branchmerge.html">上一级</a></td>
<td width="40%" align="right"> <a accesskey="n" href="svn.branchmerge.switchwc.html">下一页</a>
</td>
</tr>
<tr>
<td width="40%" align="left" valign="top">4.3. 基本合并 </td>
<td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td>
<td width="40%" align="right" valign="top"> 4.5. 使用分支</td>
</tr>
</table>
</div>
</body>
</html>
